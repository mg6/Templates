<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>C++ templates</title>

    <meta name="description" content="A presentation about C++ templates.">
    <meta name="author" content="Maciej Gamrat/BartÅ‚omiej Kordalski">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- code blocks: <pre><code data-trim contenteditable>{{ code }}</code></pre> -->

        <section>
          <h1>Templates</h1>
          <h3>C++ templates explained</h3>
          <p><small>M. Gamrat &amp; B. Kordalski</small></p>
        </section>

        <section>
          <h2>Types</h2>
          <ul>
            <li class="fragment">function templates</li>
            <li class="fragment">class templates</li>
          </ul>
        </section>

        <!--

            Function templates

        -->

        <section>
          <h2>Function templates</h2>
        </section>

        <section>
          <h2>sum(x, y)</h2>
          <p>Let's have a function that returns a sum of 2 numbers.</p>
        </section>

        <section>
          <pre class="fragment" data-fragment-index="1"><code data-trim contenteditable>
float sum(float a, float b)
{
    return a + b;
}
          </code></pre>
          <pre><code data-trim contenteditable>
int sum(int a, int b)
{
    return a + b;
}
          </code></pre>
          <pre class="fragment" data-fragment-index="2"><code data-trim contenteditable>
char sum(char a, char b)
{
    return a + b;
}
          </code></pre>
        </section>

        <section>
          <p>The code is <strong>literally the same.</strong> How about we <strong>combine</strong> it?</p>
        </section>

        <section>
          <h2>Templated version!</h2>
          <pre><code data-trim contenteditable>
template &lt;class T&gt;
T sum(T a, T b)
{
    return a + b;
}

// usage:
int     result1 = sum(4, -5);
double  result2 = sum(5.6, 2.4);
char    result3 = sum('.', ',');  // equals 'Z'
          </code></pre>
          <pre class="fragment"><code data-trim contenteditable>
int sum(int a, int b)
{
    return a + b;
}
          </code></pre>
        </section>

        <section>
          <h2>Template syntax</h2>
          <pre><code data-trim contenteditable style="text-align: center; font-size: 120%; padding: 12pt 0">
template &lt;class T&gt; /* templated function declaration here */
          </code></pre>
          <p>such as:</p>
          <pre><code data-trim contenteditable style="text-align: center; font-size: 120%; padding: 12pt 0">
/* square(x) -> return x^2 */

template &lt;class T&gt; T square(T arg) { return arg * arg; }
          </code></pre>
        </section>

        <section>
          <h2>Multiple types</h2>
          <p>We can declare multiple type parameters as well:</p>
          <pre><code data-trim contenteditable style="text-align: center; font-size: 120%; padding: 12pt 0">
template &lt;class A, class B, class C&gt; /* declaration here */
          </code></pre>
        </section>

        <section>
          <h2>Parameter naming</h2>
          <p>Type names <var>A, B, C</var> are arbitrary.</p>
          <p>Obey variable naming conventions!</p>
        </section>

        <section>
          <h2>greater(x, y)</h2>
          <p>So far, so good. Now let's write a function returning greater value of 2&nbsp;given.</p>
        </section>

        <section>
          <h2>Do we need a template here?</h2>
        </section>

        <section>
          <h2>Of course not.</h2>
          <div class="fragment">
            <p><code>#define</code> to the rescue!</p>
            <pre><code data-trim contenteditable>
#define greater(x, y) ((x) > (y) ? (x) : (y))

// usage:
float pi = 3.14f;
float e = 2.71f;

cout &lt;&lt; greater(pi, e); // pi wins here
            </code></pre>
          </div>
        </section>

        <section>
          <h2>Why our macro <del>suc</del> fails?</h2>
          <div class="fragment">
            <p>There is no type safety.</p>
            <pre><code data-trim contenteditable>
char* title = "hello there";
char* descr = "a description of a book";

greater(title, descr) // complete nonsense compiles easily!
            </code></pre>
            <p>Macro functions are just simple text replacements.</p>
          </div>
        </section>

        <section>
          <h2>Templated comparison</h2>
          <pre><code data-trim contenteditable>
template &lt;class T&gt;
T greater(T a, T b)
{
    if (a &gt; b)
        return a;

    return b;
}

// usage:
int x1 = 5;
int x2 = 3;
cout &lt;&lt; greater(x1, x2);
          </code></pre>
          <p class="fragment">What if we had big objects to compare instead of ints?</p>
        </section>

        <section>
          <h2>Use type references!</h2>
          <pre><code data-trim contenteditable>
template &lt;class T&gt;
T&amp; greater(T&amp; a, T&amp; b)
{
    if (a &gt; b)
        return a;

    return b;
}

// since we return a reference now,
// it's possible to do the following:

int x1 = 5;
int x2 = 3;

greater(x1, x2) = -7;

// which at runtime translates to:

x1 = -7;
          </code></pre>
        </section>

        <section>
          <h2>sum_array(x, n)</h2>
          <p>Now define a function that counts the sum of given array of elements.</p>
          <p>Obviously we need the array <code>x</code> and its size <code>n</code>.</p>
        </section>

        <section>
          <h2>Integer case</h2>
          <pre><code data-trim contenteditable>
int sum_array(int data[], int count)
{
    int sum = 0;

    for (int i = 0; i &lt; count; ++i)
      sum += data[i];

    return sum;
}
          </code></pre>
        </section>

        <section>
          <h2>Templated array sum</h2>
          <pre><code data-trim contenteditable>
template &lt;class T&gt;
T sum_array(T data[], int count)
{
    T sum = T();   // why not sum = 0?

    for (int i = 0; i &lt; count; ++i)
        sum += data[i];   // watch out!

    return sum;
}

// usage:
int int_array[4]    = { 1, 6, 2, 1 };
char char_array[3]  = { 'a', 'c', 'b' };
std::string text[2] = { "test", "ing" };

sum_array(int_array, 4)   // == int(10)
sum_array(char_array, 3)  // == char('&amp;')
sum_array(text, 2)        // == std::string("testing")

          </code></pre>
        </section>

        <!--

            Class templates

        -->

        <section>
          <h2>Class templates</h2>
        </section>

        <section>
          <h2>Point class</h2>
          <p>Let's have a 2D point structure.</p>
          <pre class="fragment"><code data-trim contenteditable>
struct Point
{
    int x;
    int y;
}

// usage:
Point p = {-2, 9};
          </code></pre>
        </section>

        <section>
          <h2>Adjustable precision?</h2>
          <pre class="fragment"><code data-trim contenteditable>
struct Point
{
    T x;
    T y;

    Point() : x(T()), y(T()) {}
    Point(T _x, T _y) : x(_x), y(_y) {}
    Point(const Point&amp; p) : x(p.x), y(p.y) {}
}

// usage:
Point&lt;float&gt; p(45.5f, 251.3f);
          </code></pre>
        </section>

        <section>
          <h2>Declaring templated objects</h2>
          <p>If we write:</p>
          <pre><code data-trim contenteditable style="font-size: 120%; text-align: center; padding: 12pt 0">
Point&lt;float&gt; p;
          </code></pre>
          <p>we tell the compiler to replace all <code>T</code>s in class template with <code>float</code>
          at compile time, so that the constructor can accept <code>float</code> parameters.</p>
          <p>This is called the <strong>instantiation</strong> of class template.</p>
          <p class="fragment">That's the time the compiler checks for errors.</p>
        </section>

        <section>
          <h2>More on instantiation</h2>
          <p>Specific versions of templated class are created at compile time.</p>
          <p><code>Point&lt;float&gt;</code> and Point&lt;unsigned&gt; represent two <strong>different</strong> classes!</p>
        </section>

        <section>
          <h1>THE END</h1>
          <h3>M. Gamrat &amp; B. Kordalski</h3>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night',
        transition: 'fade',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });
    </script>
  </body>
</html>
